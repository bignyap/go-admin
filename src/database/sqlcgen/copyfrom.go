// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: copyfrom.go

package sqlcgen

import (
	"context"
	"fmt"
	"io"
	"sync/atomic"

	"github.com/go-sql-driver/mysql"
	"github.com/hexon/mysqltsv"
)

var readerHandlerSequenceForCreateBillingHistories uint32 = 1

func convertRowsForCreateBillingHistories(w *io.PipeWriter, arg []CreateBillingHistoriesParams) {
	e := mysqltsv.NewEncoder(w, 8, nil)
	for _, row := range arg {
		e.AppendValue(row.BillingStartDate)
		e.AppendValue(row.BillingEndDate)
		e.AppendValue(row.TotalAmountDue)
		e.AppendValue(row.TotalCalls)
		e.AppendString(row.PaymentStatus)
		e.AppendValue(row.PaymentDate)
		e.AppendValue(row.BillingCreatedAt)
		e.AppendValue(row.SubscriptionID)
	}
	w.CloseWithError(e.Close())
}

// CreateBillingHistories uses MySQL's LOAD DATA LOCAL INFILE and is not atomic.
//
// Errors and duplicate keys are treated as warnings and insertion will
// continue, even without an error for some cases.  Use this in a transaction
// and use SHOW WARNINGS to check for any problems and roll back if you want to.
//
// Check the documentation for more information:
// https://dev.mysql.com/doc/refman/8.0/en/load-data.html#load-data-error-handling
func (q *Queries) CreateBillingHistories(ctx context.Context, arg []CreateBillingHistoriesParams) (int64, error) {
	pr, pw := io.Pipe()
	defer pr.Close()
	rh := fmt.Sprintf("CreateBillingHistories_%d", atomic.AddUint32(&readerHandlerSequenceForCreateBillingHistories, 1))
	mysql.RegisterReaderHandler(rh, func() io.Reader { return pr })
	defer mysql.DeregisterReaderHandler(rh)
	go convertRowsForCreateBillingHistories(pw, arg)
	// The string interpolation is necessary because LOAD DATA INFILE requires
	// the file name to be given as a literal string.
	result, err := q.db.ExecContext(ctx, fmt.Sprintf("LOAD DATA LOCAL INFILE '%s' INTO TABLE `billing_history` %s (billing_start_date, billing_end_date, total_amount_due, total_calls, payment_status, payment_date, billing_created_at, subscription_id)", "Reader::"+rh, mysqltsv.Escaping))
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

var readerHandlerSequenceForCreateCustomPricings uint32 = 1

func convertRowsForCreateCustomPricings(w *io.PipeWriter, arg []CreateCustomPricingsParams) {
	e := mysqltsv.NewEncoder(w, 4, nil)
	for _, row := range arg {
		e.AppendValue(row.CustomCostPerCall)
		e.AppendValue(row.CustomRateLimit)
		e.AppendValue(row.SubscriptionID)
		e.AppendValue(row.TierBasePricingID)
	}
	w.CloseWithError(e.Close())
}

// CreateCustomPricings uses MySQL's LOAD DATA LOCAL INFILE and is not atomic.
//
// Errors and duplicate keys are treated as warnings and insertion will
// continue, even without an error for some cases.  Use this in a transaction
// and use SHOW WARNINGS to check for any problems and roll back if you want to.
//
// Check the documentation for more information:
// https://dev.mysql.com/doc/refman/8.0/en/load-data.html#load-data-error-handling
func (q *Queries) CreateCustomPricings(ctx context.Context, arg []CreateCustomPricingsParams) (int64, error) {
	pr, pw := io.Pipe()
	defer pr.Close()
	rh := fmt.Sprintf("CreateCustomPricings_%d", atomic.AddUint32(&readerHandlerSequenceForCreateCustomPricings, 1))
	mysql.RegisterReaderHandler(rh, func() io.Reader { return pr })
	defer mysql.DeregisterReaderHandler(rh)
	go convertRowsForCreateCustomPricings(pw, arg)
	// The string interpolation is necessary because LOAD DATA INFILE requires
	// the file name to be given as a literal string.
	result, err := q.db.ExecContext(ctx, fmt.Sprintf("LOAD DATA LOCAL INFILE '%s' INTO TABLE `custom_endpoint_pricing` %s (custom_cost_per_call, custom_rate_limit, subscription_id, tier_base_pricing_id)", "Reader::"+rh, mysqltsv.Escaping))
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

var readerHandlerSequenceForCreateOrgPermissions uint32 = 1

func convertRowsForCreateOrgPermissions(w *io.PipeWriter, arg []CreateOrgPermissionsParams) {
	e := mysqltsv.NewEncoder(w, 3, nil)
	for _, row := range arg {
		e.AppendValue(row.ResourceTypeID)
		e.AppendString(row.PermissionCode)
		e.AppendValue(row.OrganizationID)
	}
	w.CloseWithError(e.Close())
}

// CreateOrgPermissions uses MySQL's LOAD DATA LOCAL INFILE and is not atomic.
//
// Errors and duplicate keys are treated as warnings and insertion will
// continue, even without an error for some cases.  Use this in a transaction
// and use SHOW WARNINGS to check for any problems and roll back if you want to.
//
// Check the documentation for more information:
// https://dev.mysql.com/doc/refman/8.0/en/load-data.html#load-data-error-handling
func (q *Queries) CreateOrgPermissions(ctx context.Context, arg []CreateOrgPermissionsParams) (int64, error) {
	pr, pw := io.Pipe()
	defer pr.Close()
	rh := fmt.Sprintf("CreateOrgPermissions_%d", atomic.AddUint32(&readerHandlerSequenceForCreateOrgPermissions, 1))
	mysql.RegisterReaderHandler(rh, func() io.Reader { return pr })
	defer mysql.DeregisterReaderHandler(rh)
	go convertRowsForCreateOrgPermissions(pw, arg)
	// The string interpolation is necessary because LOAD DATA INFILE requires
	// the file name to be given as a literal string.
	result, err := q.db.ExecContext(ctx, fmt.Sprintf("LOAD DATA LOCAL INFILE '%s' INTO TABLE `organization_permission` %s (resource_type_id, permission_code, organization_id)", "Reader::"+rh, mysqltsv.Escaping))
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

var readerHandlerSequenceForCreateOrgTypes uint32 = 1

func convertRowsForCreateOrgTypes(w *io.PipeWriter, organizationTypeName []string) {
	e := mysqltsv.NewEncoder(w, 1, nil)
	for _, row := range organizationTypeName {
		e.AppendString(row)
	}
	w.CloseWithError(e.Close())
}

// CreateOrgTypes uses MySQL's LOAD DATA LOCAL INFILE and is not atomic.
//
// Errors and duplicate keys are treated as warnings and insertion will
// continue, even without an error for some cases.  Use this in a transaction
// and use SHOW WARNINGS to check for any problems and roll back if you want to.
//
// Check the documentation for more information:
// https://dev.mysql.com/doc/refman/8.0/en/load-data.html#load-data-error-handling
func (q *Queries) CreateOrgTypes(ctx context.Context, organizationTypeName []string) (int64, error) {
	pr, pw := io.Pipe()
	defer pr.Close()
	rh := fmt.Sprintf("CreateOrgTypes_%d", atomic.AddUint32(&readerHandlerSequenceForCreateOrgTypes, 1))
	mysql.RegisterReaderHandler(rh, func() io.Reader { return pr })
	defer mysql.DeregisterReaderHandler(rh)
	go convertRowsForCreateOrgTypes(pw, organizationTypeName)
	// The string interpolation is necessary because LOAD DATA INFILE requires
	// the file name to be given as a literal string.
	result, err := q.db.ExecContext(ctx, fmt.Sprintf("LOAD DATA LOCAL INFILE '%s' INTO TABLE `organization_type` %s (organization_type_name)", "Reader::"+rh, mysqltsv.Escaping))
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

var readerHandlerSequenceForCreateOrganizations uint32 = 1

func convertRowsForCreateOrganizations(w *io.PipeWriter, arg []CreateOrganizationsParams) {
	e := mysqltsv.NewEncoder(w, 10, nil)
	for _, row := range arg {
		e.AppendString(row.OrganizationName)
		e.AppendValue(row.OrganizationCreatedAt)
		e.AppendValue(row.OrganizationUpdatedAt)
		e.AppendString(row.OrganizationRealm)
		e.AppendValue(row.OrganizationCountry)
		e.AppendString(row.OrganizationSupportEmail)
		e.AppendValue(row.OrganizationActive)
		e.AppendValue(row.OrganizationReportQ)
		e.AppendValue(row.OrganizationConfig)
		e.AppendValue(row.OrganizationTypeID)
	}
	w.CloseWithError(e.Close())
}

// CreateOrganizations uses MySQL's LOAD DATA LOCAL INFILE and is not atomic.
//
// Errors and duplicate keys are treated as warnings and insertion will
// continue, even without an error for some cases.  Use this in a transaction
// and use SHOW WARNINGS to check for any problems and roll back if you want to.
//
// Check the documentation for more information:
// https://dev.mysql.com/doc/refman/8.0/en/load-data.html#load-data-error-handling
func (q *Queries) CreateOrganizations(ctx context.Context, arg []CreateOrganizationsParams) (int64, error) {
	pr, pw := io.Pipe()
	defer pr.Close()
	rh := fmt.Sprintf("CreateOrganizations_%d", atomic.AddUint32(&readerHandlerSequenceForCreateOrganizations, 1))
	mysql.RegisterReaderHandler(rh, func() io.Reader { return pr })
	defer mysql.DeregisterReaderHandler(rh)
	go convertRowsForCreateOrganizations(pw, arg)
	// The string interpolation is necessary because LOAD DATA INFILE requires
	// the file name to be given as a literal string.
	result, err := q.db.ExecContext(ctx, fmt.Sprintf("LOAD DATA LOCAL INFILE '%s' INTO TABLE `organization` %s (organization_name, organization_created_at, organization_updated_at, organization_realm, organization_country, organization_support_email, organization_active, organization_report_q, organization_config, organization_type_id)", "Reader::"+rh, mysqltsv.Escaping))
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

var readerHandlerSequenceForCreateResourceTypes uint32 = 1

func convertRowsForCreateResourceTypes(w *io.PipeWriter, arg []CreateResourceTypesParams) {
	e := mysqltsv.NewEncoder(w, 3, nil)
	for _, row := range arg {
		e.AppendString(row.ResourceTypeName)
		e.AppendString(row.ResourceTypeCode)
		e.AppendValue(row.ResourceTypeDescription)
	}
	w.CloseWithError(e.Close())
}

// CreateResourceTypes uses MySQL's LOAD DATA LOCAL INFILE and is not atomic.
//
// Errors and duplicate keys are treated as warnings and insertion will
// continue, even without an error for some cases.  Use this in a transaction
// and use SHOW WARNINGS to check for any problems and roll back if you want to.
//
// Check the documentation for more information:
// https://dev.mysql.com/doc/refman/8.0/en/load-data.html#load-data-error-handling
func (q *Queries) CreateResourceTypes(ctx context.Context, arg []CreateResourceTypesParams) (int64, error) {
	pr, pw := io.Pipe()
	defer pr.Close()
	rh := fmt.Sprintf("CreateResourceTypes_%d", atomic.AddUint32(&readerHandlerSequenceForCreateResourceTypes, 1))
	mysql.RegisterReaderHandler(rh, func() io.Reader { return pr })
	defer mysql.DeregisterReaderHandler(rh)
	go convertRowsForCreateResourceTypes(pw, arg)
	// The string interpolation is necessary because LOAD DATA INFILE requires
	// the file name to be given as a literal string.
	result, err := q.db.ExecContext(ctx, fmt.Sprintf("LOAD DATA LOCAL INFILE '%s' INTO TABLE `resource_type` %s (resource_type_name, resource_type_code, resource_type_description)", "Reader::"+rh, mysqltsv.Escaping))
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

var readerHandlerSequenceForCreateSubscriptionTiers uint32 = 1

func convertRowsForCreateSubscriptionTiers(w *io.PipeWriter, arg []CreateSubscriptionTiersParams) {
	e := mysqltsv.NewEncoder(w, 4, nil)
	for _, row := range arg {
		e.AppendString(row.TierName)
		e.AppendValue(row.TierDescription)
		e.AppendValue(row.TierCreatedAt)
		e.AppendValue(row.TierUpdatedAt)
	}
	w.CloseWithError(e.Close())
}

// CreateSubscriptionTiers uses MySQL's LOAD DATA LOCAL INFILE and is not atomic.
//
// Errors and duplicate keys are treated as warnings and insertion will
// continue, even without an error for some cases.  Use this in a transaction
// and use SHOW WARNINGS to check for any problems and roll back if you want to.
//
// Check the documentation for more information:
// https://dev.mysql.com/doc/refman/8.0/en/load-data.html#load-data-error-handling
func (q *Queries) CreateSubscriptionTiers(ctx context.Context, arg []CreateSubscriptionTiersParams) (int64, error) {
	pr, pw := io.Pipe()
	defer pr.Close()
	rh := fmt.Sprintf("CreateSubscriptionTiers_%d", atomic.AddUint32(&readerHandlerSequenceForCreateSubscriptionTiers, 1))
	mysql.RegisterReaderHandler(rh, func() io.Reader { return pr })
	defer mysql.DeregisterReaderHandler(rh)
	go convertRowsForCreateSubscriptionTiers(pw, arg)
	// The string interpolation is necessary because LOAD DATA INFILE requires
	// the file name to be given as a literal string.
	result, err := q.db.ExecContext(ctx, fmt.Sprintf("LOAD DATA LOCAL INFILE '%s' INTO TABLE `subscription_tier` %s (tier_name, tier_description, tier_created_at, tier_updated_at)", "Reader::"+rh, mysqltsv.Escaping))
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

var readerHandlerSequenceForCreateSubscriptions uint32 = 1

func convertRowsForCreateSubscriptions(w *io.PipeWriter, arg []CreateSubscriptionsParams) {
	e := mysqltsv.NewEncoder(w, 11, nil)
	for _, row := range arg {
		e.AppendString(row.SubscriptionName)
		e.AppendString(row.SubscriptionType)
		e.AppendValue(row.SubscriptionCreatedDate)
		e.AppendValue(row.SubscriptionUpdatedDate)
		e.AppendValue(row.SubscriptionStartDate)
		e.AppendValue(row.SubscriptionApiLimit)
		e.AppendValue(row.SubscriptionExpiryDate)
		e.AppendValue(row.SubscriptionDescription)
		e.AppendValue(row.SubscriptionStatus)
		e.AppendValue(row.OrganizationID)
		e.AppendValue(row.SubscriptionTierID)
	}
	w.CloseWithError(e.Close())
}

// CreateSubscriptions uses MySQL's LOAD DATA LOCAL INFILE and is not atomic.
//
// Errors and duplicate keys are treated as warnings and insertion will
// continue, even without an error for some cases.  Use this in a transaction
// and use SHOW WARNINGS to check for any problems and roll back if you want to.
//
// Check the documentation for more information:
// https://dev.mysql.com/doc/refman/8.0/en/load-data.html#load-data-error-handling
func (q *Queries) CreateSubscriptions(ctx context.Context, arg []CreateSubscriptionsParams) (int64, error) {
	pr, pw := io.Pipe()
	defer pr.Close()
	rh := fmt.Sprintf("CreateSubscriptions_%d", atomic.AddUint32(&readerHandlerSequenceForCreateSubscriptions, 1))
	mysql.RegisterReaderHandler(rh, func() io.Reader { return pr })
	defer mysql.DeregisterReaderHandler(rh)
	go convertRowsForCreateSubscriptions(pw, arg)
	// The string interpolation is necessary because LOAD DATA INFILE requires
	// the file name to be given as a literal string.
	result, err := q.db.ExecContext(ctx, fmt.Sprintf("LOAD DATA LOCAL INFILE '%s' INTO TABLE `subscription` %s (subscription_name, subscription_type, subscription_created_date, subscription_updated_date, subscription_start_date, subscription_api_limit, subscription_expiry_date, subscription_description, subscription_status, organization_id, subscription_tier_id)", "Reader::"+rh, mysqltsv.Escaping))
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

var readerHandlerSequenceForCreateTierPricings uint32 = 1

func convertRowsForCreateTierPricings(w *io.PipeWriter, arg []CreateTierPricingsParams) {
	e := mysqltsv.NewEncoder(w, 4, nil)
	for _, row := range arg {
		e.AppendValue(row.SubscriptionTierID)
		e.AppendValue(row.ApiEndpointID)
		e.AppendValue(row.BaseCostPerCall)
		e.AppendValue(row.BaseRateLimit)
	}
	w.CloseWithError(e.Close())
}

// CreateTierPricings uses MySQL's LOAD DATA LOCAL INFILE and is not atomic.
//
// Errors and duplicate keys are treated as warnings and insertion will
// continue, even without an error for some cases.  Use this in a transaction
// and use SHOW WARNINGS to check for any problems and roll back if you want to.
//
// Check the documentation for more information:
// https://dev.mysql.com/doc/refman/8.0/en/load-data.html#load-data-error-handling
func (q *Queries) CreateTierPricings(ctx context.Context, arg []CreateTierPricingsParams) (int64, error) {
	pr, pw := io.Pipe()
	defer pr.Close()
	rh := fmt.Sprintf("CreateTierPricings_%d", atomic.AddUint32(&readerHandlerSequenceForCreateTierPricings, 1))
	mysql.RegisterReaderHandler(rh, func() io.Reader { return pr })
	defer mysql.DeregisterReaderHandler(rh)
	go convertRowsForCreateTierPricings(pw, arg)
	// The string interpolation is necessary because LOAD DATA INFILE requires
	// the file name to be given as a literal string.
	result, err := q.db.ExecContext(ctx, fmt.Sprintf("LOAD DATA LOCAL INFILE '%s' INTO TABLE `tier_base_pricing` %s (subscription_tier_id, api_endpoint_id, base_cost_per_call, base_rate_limit)", "Reader::"+rh, mysqltsv.Escaping))
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

var readerHandlerSequenceForRegisterApiEndpoints uint32 = 1

func convertRowsForRegisterApiEndpoints(w *io.PipeWriter, arg []RegisterApiEndpointsParams) {
	e := mysqltsv.NewEncoder(w, 2, nil)
	for _, row := range arg {
		e.AppendString(row.EndpointName)
		e.AppendValue(row.EndpointDescription)
	}
	w.CloseWithError(e.Close())
}

// RegisterApiEndpoints uses MySQL's LOAD DATA LOCAL INFILE and is not atomic.
//
// Errors and duplicate keys are treated as warnings and insertion will
// continue, even without an error for some cases.  Use this in a transaction
// and use SHOW WARNINGS to check for any problems and roll back if you want to.
//
// Check the documentation for more information:
// https://dev.mysql.com/doc/refman/8.0/en/load-data.html#load-data-error-handling
func (q *Queries) RegisterApiEndpoints(ctx context.Context, arg []RegisterApiEndpointsParams) (int64, error) {
	pr, pw := io.Pipe()
	defer pr.Close()
	rh := fmt.Sprintf("RegisterApiEndpoints_%d", atomic.AddUint32(&readerHandlerSequenceForRegisterApiEndpoints, 1))
	mysql.RegisterReaderHandler(rh, func() io.Reader { return pr })
	defer mysql.DeregisterReaderHandler(rh)
	go convertRowsForRegisterApiEndpoints(pw, arg)
	// The string interpolation is necessary because LOAD DATA INFILE requires
	// the file name to be given as a literal string.
	result, err := q.db.ExecContext(ctx, fmt.Sprintf("LOAD DATA LOCAL INFILE '%s' INTO TABLE `api_endpoint` %s (endpoint_name, endpoint_description)", "Reader::"+rh, mysqltsv.Escaping))
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
