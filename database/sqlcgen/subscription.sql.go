// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: subscription.sql

package sqlcgen

import (
	"context"
	"database/sql"
	"time"
)

const createSubscription = `-- name: CreateSubscription :execresult
INSERT INTO subscription (
    subscription_name, subscription_type, subscription_created_date,
    subscription_updated_date, subscription_start_date, subscription_api_limit, 
    subscription_expiry_date, subscription_description, subscription_status, 
    organization_id, subscription_tier_id
) 
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateSubscriptionParams struct {
	SubscriptionName        string
	SubscriptionType        string
	SubscriptionCreatedDate time.Time
	SubscriptionUpdatedDate time.Time
	SubscriptionStartDate   time.Time
	SubscriptionApiLimit    sql.NullInt32
	SubscriptionExpiryDate  sql.NullTime
	SubscriptionDescription sql.NullString
	SubscriptionStatus      sql.NullBool
	OrganizationID          int32
	SubscriptionTierID      int32
}

func (q *Queries) CreateSubscription(ctx context.Context, arg CreateSubscriptionParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createSubscription,
		arg.SubscriptionName,
		arg.SubscriptionType,
		arg.SubscriptionCreatedDate,
		arg.SubscriptionUpdatedDate,
		arg.SubscriptionStartDate,
		arg.SubscriptionApiLimit,
		arg.SubscriptionExpiryDate,
		arg.SubscriptionDescription,
		arg.SubscriptionStatus,
		arg.OrganizationID,
		arg.SubscriptionTierID,
	)
}

const deleteSubscriptionById = `-- name: DeleteSubscriptionById :exec
DELETE FROM subscription
WHERE subscription_id = ?
`

func (q *Queries) DeleteSubscriptionById(ctx context.Context, subscriptionID int32) error {
	_, err := q.db.ExecContext(ctx, deleteSubscriptionById, subscriptionID)
	return err
}

const deleteSubscriptionByOrgId = `-- name: DeleteSubscriptionByOrgId :exec
DELETE FROM subscription
WHERE organization_id = ?
`

func (q *Queries) DeleteSubscriptionByOrgId(ctx context.Context, organizationID int32) error {
	_, err := q.db.ExecContext(ctx, deleteSubscriptionByOrgId, organizationID)
	return err
}

const getSubscriptionById = `-- name: GetSubscriptionById :one
SELECT subscription_id, subscription_name, subscription_type, subscription_created_date, subscription_updated_date, subscription_start_date, subscription_api_limit, subscription_expiry_date, subscription_description, subscription_status, organization_id, subscription_tier_id FROM subscription
WHERE subscription_id = ?
`

func (q *Queries) GetSubscriptionById(ctx context.Context, subscriptionID int32) (Subscription, error) {
	row := q.db.QueryRowContext(ctx, getSubscriptionById, subscriptionID)
	var i Subscription
	err := row.Scan(
		&i.SubscriptionID,
		&i.SubscriptionName,
		&i.SubscriptionType,
		&i.SubscriptionCreatedDate,
		&i.SubscriptionUpdatedDate,
		&i.SubscriptionStartDate,
		&i.SubscriptionApiLimit,
		&i.SubscriptionExpiryDate,
		&i.SubscriptionDescription,
		&i.SubscriptionStatus,
		&i.OrganizationID,
		&i.SubscriptionTierID,
	)
	return i, err
}

const getSubscriptionByOrgId = `-- name: GetSubscriptionByOrgId :many
SELECT subscription_id, subscription_name, subscription_type, subscription_created_date, subscription_updated_date, subscription_start_date, subscription_api_limit, subscription_expiry_date, subscription_description, subscription_status, organization_id, subscription_tier_id FROM subscription
WHERE organization_id = ?
`

func (q *Queries) GetSubscriptionByOrgId(ctx context.Context, organizationID int32) ([]Subscription, error) {
	rows, err := q.db.QueryContext(ctx, getSubscriptionByOrgId, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Subscription
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.SubscriptionID,
			&i.SubscriptionName,
			&i.SubscriptionType,
			&i.SubscriptionCreatedDate,
			&i.SubscriptionUpdatedDate,
			&i.SubscriptionStartDate,
			&i.SubscriptionApiLimit,
			&i.SubscriptionExpiryDate,
			&i.SubscriptionDescription,
			&i.SubscriptionStatus,
			&i.OrganizationID,
			&i.SubscriptionTierID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubscription = `-- name: ListSubscription :many
SELECT subscription_id, subscription_name, subscription_type, subscription_created_date, subscription_updated_date, subscription_start_date, subscription_api_limit, subscription_expiry_date, subscription_description, subscription_status, organization_id, subscription_tier_id FROM subscription
ORDER BY subscription_name
`

func (q *Queries) ListSubscription(ctx context.Context) ([]Subscription, error) {
	rows, err := q.db.QueryContext(ctx, listSubscription)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Subscription
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.SubscriptionID,
			&i.SubscriptionName,
			&i.SubscriptionType,
			&i.SubscriptionCreatedDate,
			&i.SubscriptionUpdatedDate,
			&i.SubscriptionStartDate,
			&i.SubscriptionApiLimit,
			&i.SubscriptionExpiryDate,
			&i.SubscriptionDescription,
			&i.SubscriptionStatus,
			&i.OrganizationID,
			&i.SubscriptionTierID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSubscription = `-- name: UpdateSubscription :execresult
UPDATE subscription
SET 
    subscription_name = ?,
    subscription_start_date = ?,
    subscription_api_limit = ?,
    subscription_expiry_date = ?,
    subscription_description = ?,
    subscription_status = ?,
    organization_id = ?,
    subscription_tier_id = ?
WHERE subscription_id = ?
`

type UpdateSubscriptionParams struct {
	SubscriptionName        string
	SubscriptionStartDate   time.Time
	SubscriptionApiLimit    sql.NullInt32
	SubscriptionExpiryDate  sql.NullTime
	SubscriptionDescription sql.NullString
	SubscriptionStatus      sql.NullBool
	OrganizationID          int32
	SubscriptionTierID      int32
	SubscriptionID          int32
}

func (q *Queries) UpdateSubscription(ctx context.Context, arg UpdateSubscriptionParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateSubscription,
		arg.SubscriptionName,
		arg.SubscriptionStartDate,
		arg.SubscriptionApiLimit,
		arg.SubscriptionExpiryDate,
		arg.SubscriptionDescription,
		arg.SubscriptionStatus,
		arg.OrganizationID,
		arg.SubscriptionTierID,
		arg.SubscriptionID,
	)
}
