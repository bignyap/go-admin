// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: billing_history.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

type CreateBillingHistoriesParams struct {
	BillingStartDate int32
	BillingEndDate   int32
	TotalAmountDue   float64
	TotalCalls       int32
	PaymentStatus    string
	PaymentDate      pgtype.Int4
	BillingCreatedAt int32
	SubscriptionID   int32
}

const createBillingHistory = `-- name: CreateBillingHistory :one
INSERT INTO billing_history (
    billing_start_date, billing_end_date, total_amount_due,
    total_calls, payment_status, payment_date, 
    billing_created_at, subscription_id
) 
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING billing_id
`

type CreateBillingHistoryParams struct {
	BillingStartDate int32
	BillingEndDate   int32
	TotalAmountDue   float64
	TotalCalls       int32
	PaymentStatus    string
	PaymentDate      pgtype.Int4
	BillingCreatedAt int32
	SubscriptionID   int32
}

func (q *Queries) CreateBillingHistory(ctx context.Context, arg CreateBillingHistoryParams) (int32, error) {
	row := q.db.QueryRow(ctx, createBillingHistory,
		arg.BillingStartDate,
		arg.BillingEndDate,
		arg.TotalAmountDue,
		arg.TotalCalls,
		arg.PaymentStatus,
		arg.PaymentDate,
		arg.BillingCreatedAt,
		arg.SubscriptionID,
	)
	var billing_id int32
	err := row.Scan(&billing_id)
	return billing_id, err
}

const getBillingHistoryById = `-- name: GetBillingHistoryById :many
SELECT billing_id, billing_start_date, billing_end_date, total_amount_due, total_calls, payment_status, payment_date, billing_created_at, subscription_id FROM billing_history
WHERE billing_id = $1
LIMIT $2 OFFSET $3
`

type GetBillingHistoryByIdParams struct {
	BillingID int32
	Limit     int32
	Offset    int32
}

func (q *Queries) GetBillingHistoryById(ctx context.Context, arg GetBillingHistoryByIdParams) ([]BillingHistory, error) {
	rows, err := q.db.Query(ctx, getBillingHistoryById, arg.BillingID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []BillingHistory{}
	for rows.Next() {
		var i BillingHistory
		if err := rows.Scan(
			&i.BillingID,
			&i.BillingStartDate,
			&i.BillingEndDate,
			&i.TotalAmountDue,
			&i.TotalCalls,
			&i.PaymentStatus,
			&i.PaymentDate,
			&i.BillingCreatedAt,
			&i.SubscriptionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBillingHistoryByOrgId = `-- name: GetBillingHistoryByOrgId :many
SELECT billing_id, billing_start_date, billing_end_date, total_amount_due, total_calls, payment_status, payment_date, billing_created_at, subscription_id FROM billing_history
WHERE subscription_id IN (
    SELECT subscription_id FROM subscription
    WHERE organization_id = $1
)
LIMIT $2 OFFSET $3
`

type GetBillingHistoryByOrgIdParams struct {
	OrganizationID int32
	Limit          int32
	Offset         int32
}

func (q *Queries) GetBillingHistoryByOrgId(ctx context.Context, arg GetBillingHistoryByOrgIdParams) ([]BillingHistory, error) {
	rows, err := q.db.Query(ctx, getBillingHistoryByOrgId, arg.OrganizationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []BillingHistory{}
	for rows.Next() {
		var i BillingHistory
		if err := rows.Scan(
			&i.BillingID,
			&i.BillingStartDate,
			&i.BillingEndDate,
			&i.TotalAmountDue,
			&i.TotalCalls,
			&i.PaymentStatus,
			&i.PaymentDate,
			&i.BillingCreatedAt,
			&i.SubscriptionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBillingHistoryBySubId = `-- name: GetBillingHistoryBySubId :many
SELECT billing_id, billing_start_date, billing_end_date, total_amount_due, total_calls, payment_status, payment_date, billing_created_at, subscription_id FROM billing_history
WHERE subscription_id = $1
LIMIT $2 OFFSET $3
`

type GetBillingHistoryBySubIdParams struct {
	SubscriptionID int32
	Limit          int32
	Offset         int32
}

func (q *Queries) GetBillingHistoryBySubId(ctx context.Context, arg GetBillingHistoryBySubIdParams) ([]BillingHistory, error) {
	rows, err := q.db.Query(ctx, getBillingHistoryBySubId, arg.SubscriptionID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []BillingHistory{}
	for rows.Next() {
		var i BillingHistory
		if err := rows.Scan(
			&i.BillingID,
			&i.BillingStartDate,
			&i.BillingEndDate,
			&i.TotalAmountDue,
			&i.TotalCalls,
			&i.PaymentStatus,
			&i.PaymentDate,
			&i.BillingCreatedAt,
			&i.SubscriptionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
